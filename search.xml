<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法学习之递归、迭代、分治法</title>
      <link href="/2020/01/05/recursive-iteration-divide/"/>
      <url>/2020/01/05/recursive-iteration-divide/</url>
      
        <content type="html"><![CDATA[<h2 id="递归、迭代和分治法"><a href="#递归、迭代和分治法" class="headerlink" title="递归、迭代和分治法"></a>递归、迭代和分治法</h2><h3 id="一、递归算法"><a href="#一、递归算法" class="headerlink" title="一、递归算法"></a>一、递归算法</h3><blockquote><p>通过不断调用自身，但是相对的每次调用自己时候，所解决的问题规模较小，比较符合分治的思想。</p></blockquote><p>1、使用递归要注意的有两点:</p><p>递归就是在过程或函数里面调用自身;在使用递归时,必须有一个明确的递归结束条件,称为递归出口.</p><p>2、递归分为两个阶段:</p><p>递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;<br>回归:当获得最简单的情况后,逐步返回,依次得到复杂的解.<br>利用递归可以解决很多问题:如背包问题,汉诺塔问题,…等.</p><p>3、优缺点</p><p>优点：结构清晰，可读性强，且容易用数学归纳法证明算法的正确性。<br>缺点：(1) 递归算法需要调用递归栈存放函数的变量、计算结果等直至return后才会释放该栈，所以消耗内存空间；<br>　　　(2) 可能存在重复计算相同的子问题。</p><h3 id="二、分治法"><a href="#二、分治法" class="headerlink" title="二、分治法"></a>二、分治法</h3><blockquote><p>将一个规模为n的问题分解为k个规模较小的子问题，这些子问题相互独立且与原问题相同，然后递归地解这些子问题，最后将各个子问题的解合并得到原问题的解。</p></blockquote><p>应用：二分搜索、大整数乘法。</p><h3 id="三、迭代"><a href="#三、迭代" class="headerlink" title="三、迭代"></a>三、迭代</h3><blockquote><p>从小规模的问题，逐步累积出较大问题的解，最终获得所需要解决问题的解</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21.合并两个有序列表 (leetcode easy)</title>
      <link href="/2020/01/02/merge-two-sorted-lists/"/>
      <url>/2020/01/02/merge-two-sorted-lists/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></blockquote><p><img src="/2020/01/02/merge-two-sorted-lists/example.png" alt="示例"></p><h2 id="思路一：递归"><a href="#思路一：递归" class="headerlink" title="思路一：递归"></a>思路一：递归</h2><p>本题递归三要素：<br>1、终止条件：两条链表分别名为<code>l1</code>和<code>l2</code>，当<code>l1</code>或<code>l2</code>为空时结束<br>2、返回值：每一层调用都返回排序好的链表头<br>3、递归内容：如果<code>l1</code>的<code>val</code>值更小，则将<code>l1.next</code>与排序好的链表头相接，<code>l2</code>同理</p><p>时间复杂度：O(m+n)，m为<code>l1</code>的长度，n为<code>l2</code>的长度<br>空间复杂度：O(m+n)，递归结束后，<code>l1</code>和<code>l2</code>的每个元素都已经遍历过了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路二：迭代"><a href="#思路二：迭代" class="headerlink" title="思路二：迭代"></a>思路二：迭代</h2><p>设定哨兵节点“<code>prehead</code>“，这可以在最后让我们比较容易的返回合并后的链表，然后我们只需要维护一个<code>prev</code>指针，需要做的是调整它的<code>next</code>指针。然后，我们重复以下过程，直到<code>l1</code>或者<code>l2</code>指向了<code>null</code>：如果<code>l1</code>当前位置的值小于等于<code>l2</code>，我们就把<code>l1</code>的值接在<code>prev</code>节点的后面同时将<code>l1</code>指针往后移一位，否则操作<code>l2</code>。不管我们将哪一个元素接在后面，都将<code>prev</code>向后移一个元素</p><p>在循环终止的时候，<code>l1</code>和<code>l2</code>至多有一个非空的。由于输入的两个链表都是有序的，所以不管哪个链表非空，它包含的所有元素都比前面已经合并链表中的元素大，所有我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prehead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prev = prehead;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            prev.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prehead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> Leetcode </category>
          
          <category> linkedList </category>
          
          <category> 腾讯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> Leetcode </tag>
            
            <tag> linkedList </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.两数相加 (leetcode mid)</title>
      <link href="/2019/12/31/add-two-numbers/"/>
      <url>/2019/12/31/add-two-numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p></blockquote><p><img src="/2019/12/31/add-two-numbers/example.png" alt="示例"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、标签：链表<br>2、将两个链表按长的进行遍历，如果遇到短链表不够长度则在前面补0，比如<code>987 + 23 = 987 + 023 = 1010</code><br>3、每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值<br>4、如果两个链表都遍历完后，进位值仍为1，则在新链表最前方添加节点1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = l1;</span><br><span class="line">    <span class="keyword">let</span> p2 = l2;</span><br><span class="line">    <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">    <span class="keyword">let</span> pointer = dummy;</span><br><span class="line">    <span class="keyword">while</span> (p1 || p2) &#123;</span><br><span class="line">        <span class="keyword">const</span> num1 = p1 ? p1.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> num2 = p2 ? p2.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> sum = num1 + num2 + carry;</span><br><span class="line">        carry = <span class="built_in">parseInt</span>(sum / <span class="number">10</span>);</span><br><span class="line">        pointer.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (p1) p1 = p1.next</span><br><span class="line">        <span class="keyword">if</span> (p2) p2 = p2.next</span><br><span class="line">        pointer = pointer.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry == <span class="number">1</span>) &#123;</span><br><span class="line">        pointer.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> Leetcode </category>
          
          <category> linkedList </category>
          
          <category> Leetcode,腾讯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> Leetcode </tag>
            
            <tag> linkedList </tag>
            
            <tag> 腾讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>74.搜索二维矩阵 (leetcode mid)</title>
      <link href="/2019/12/30/search-a-2d-matrix/"/>
      <url>/2019/12/30/search-a-2d-matrix/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：<br>&nbsp;&nbsp;&nbsp;&nbsp;1、每行中的整数从左到右按升序排列。<br>&nbsp;&nbsp;&nbsp;&nbsp;2、每行的第一个整数大于前一行的最后一个整数。</p><p><img src="/2019/12/30/search-a-2d-matrix/example.png" alt="示例"></p><h2 id="思路一：骚操作"><a href="#思路一：骚操作" class="headerlink" title="思路一：骚操作"></a>思路一：骚操作</h2><blockquote><p>可以看到本题目的是操作数组中是否有目标值，那么我们可以使用数组方法<code>includes()</code>,但是这里是二维数组，那么我们可以用数组的<code>flat()</code>方法来将二维数组转为一维数组。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> matrix.flat().includes(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 兼容代码</span></span><br><span class="line"><span class="keyword">var</span> searchMatrix = <span class="function"><span class="keyword">function</span> (<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].concat(...matrix).includes(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路二：递归"><a href="#思路二：递归" class="headerlink" title="思路二：递归"></a>思路二：递归</h2><blockquote><p>我们可以采用递进式的方法，从二维数组的右上角开始比对</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (matrix.length === <span class="number">0</span> || (matrix.length &gt; <span class="number">0</span> &amp;&amp; matrix[<span class="number">0</span>].length === <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> m = matrix.length,</span><br><span class="line">      n = matrix[<span class="number">0</span>].length,</span><br><span class="line">      i = <span class="number">0</span>,</span><br><span class="line">      j = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;m &amp;&amp; j&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix[i][j] &gt; target)&#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target)&#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路三：二分法"><a href="#思路三：二分法" class="headerlink" title="思路三：二分法"></a>思路三：二分法</h2><blockquote><p>此题的二维数组可以被看作是一个升序的一维数组，那么我们就可以直接使用二分法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (matrix.length === <span class="number">0</span> || (matrix.length &gt; <span class="number">0</span> &amp;&amp; matrix[<span class="number">0</span>].length === <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> start,mid,num;</span><br><span class="line">  <span class="keyword">let</span> m = matrix.length,</span><br><span class="line">      n = matrix[<span class="number">0</span>].length,</span><br><span class="line">      end = m * n - <span class="number">1</span>;</span><br><span class="line">  start = mid = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    mid = <span class="built_in">parseInt</span>((start + end) / <span class="number">2</span>);</span><br><span class="line">    num = matrix[<span class="built_in">parseInt</span>(mid / n)][mid % n];</span><br><span class="line">    <span class="keyword">if</span> (target == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (target &lt; num) end = mid - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>162.寻找峰值 (leetcode mid)</title>
      <link href="/2019/12/29/find-peak-element/"/>
      <url>/2019/12/29/find-peak-element/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>峰值元素是指其值大于左右相邻值的元素。<br>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。<br>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。<br>你可以假设 nums[-1] = nums[n] = -∞。</p></blockquote><p><img src="/2019/12/29/find-peak-element/example.png" alt="示例"></p><blockquote><p>说明：你的解法应该是 O(logN) 时间复杂度的。</p></blockquote><h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p>1、标签：暴力法<br>2、过程：<br>题目给出了<code>muns[-1] = nums[n] = -∞</code>，所以<code>nums[0] &gt; nums[-1]</code>必定成立，那么我们只需要遍历数组，找到第一个i使得<code>nums[i] &gt; nums[i+1]</code>；<br>例如：<code>nums[0] &gt; nums[1]</code>,且此时<code>nums[0] &gt; nums[-1]</code>，则得出峰值元素下标为<code>0</code>。<br>3、时间复杂度：最差的情况下为O(n)，最好的情况下为O(1)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findPeakElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (nums.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/29/find-peak-element/submit2.png" alt="提交"></p><h2 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h2><p>1、标签：二分查找<br>2、过程：<br>    i.首先要注意题目条件，在题目描述中出现了 <code>nums[-1] = nums[n] = -∞</code>，这就代表着 只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值<br>    ii.根据上述结论，我们就可以使用二分查找找到峰值<br>    iii.查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件<br>    Vi.根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r = m，如果 m + 1 较大，则右侧存在峰值，l = m + 1<br>3、时间复杂度：O(logN)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findPeakElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 题目要求时间复杂度为O(logn)，那么我们就想到可以使用二分法解决；</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> star = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> mid;</span><br><span class="line">    <span class="keyword">while</span>( star &lt; end ) &#123;</span><br><span class="line">        mid = <span class="built_in">parseInt</span>((star + end) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            star = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> star;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/29/find-peak-element/submit1.png" alt="提交"></p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>41.缺失的第一个正数 (leetcode hard)</title>
      <link href="/2019/12/27/first-missing-positive/"/>
      <url>/2019/12/27/first-missing-positive/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="/2019/12/27/first-missing-positive/example.png" alt="示例"></p><h2 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>遍历一次数组把大于等于1的和小于数组大小的值放到原数组对应位置，然后再遍历一次数组查当前下标是否和值对应，如果不对应那这个下标就是答案，否则遍历完都没出现那么答案就是数组长度加1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums.length === <span class="number">0</span> || (nums.length === <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] != <span class="number">1</span>) ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">i,j</span>)</span>&#123;</span><br><span class="line">  nums[i] = nums[i] ^ nums[j];</span><br><span class="line">  nums[j] = nums[i] ^ nums[j];</span><br><span class="line">  nums[i] = nums[i] ^ nums[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="keyword">let</span> len = nums.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">  <span class="comment">// 新索引 nums[i] 处于 [1,length] 且不等于自身（如第三项不能为3：nums[2]!==3） 且 nums[新索引] 未排好</span></span><br><span class="line">  <span class="keyword">while</span>(nums[i]&gt;=<span class="number">1</span>&amp;&amp;nums[i]&lt;=len&amp;&amp;nums[i]!==i+<span class="number">1</span>&amp;&amp;nums[nums[i]<span class="number">-1</span>]!==nums[i])&#123;</span><br><span class="line">    swap(i,nums[i]<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums[j]!==j+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> j+<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/2019/12/27/first-missing-positive/submit1.png" alt="提交"></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>定义空数组，循环目标数组，将空数组中对应目标数组值的下标设为true；<br>最后遍历定义的数组，返回第一个值不为true的下标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[],len=nums.length;</span><br><span class="line"><span class="keyword">if</span>(len===<span class="number">0</span>||len===<span class="number">1</span>&amp;&amp;nums[<span class="number">0</span>]!==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums[i]&gt;=<span class="number">0</span>)arr[nums[i]]=<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!arr.length)<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> len1=arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!arr[i])&#123;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i===len1<span class="number">-1</span>)<span class="keyword">return</span> len1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/27/first-missing-positive/submit2.png" alt="提交"></p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript深入之闭包</title>
      <link href="/2019/12/26/closure/"/>
      <url>/2019/12/26/closure/</url>
      
        <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>闭包（closure）属于<code>Javascript</code>的一个难点，很多高级应用都需要依赖闭包实现；</p><p>首先先来个例子：</p><p>例子一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Heternally'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">getName(); <span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure><p>可以看到，函数<code>getName</code>内可以读取全局变量；但是，在函数外就无法读取函数内部声明的变量。</p><p>例子二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Heternally'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// name is not defined</span></span><br></pre></td></tr></table></figure><p>有同学看到这可能会说，这不是作用域链的问题嘛，但是咱在这里是为了引出闭包；</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">MDN</a>给到闭包的定义是：</p><blockquote><p>闭包是指那些能够访问自由变量的函数</p></blockquote><p>什么是自由变量呢？</p><blockquote><p>自由变量是指在函数中使用，但既不是函数的参数也不是函数局部变量的变量，其实就是另一个函数作用域中的变量</p></blockquote><p>关于这个也可以从<strong>红宝书</strong>上对于闭包的定义中看出：<strong>闭包是指有权访问另外一个函数作用域的变量的函数</strong></p><p>因此，可以得出闭包由两部分组成：</p><blockquote><p>闭包 = 函数 + 函数可访问的自由变量</p></blockquote><p><strong>现在我们再来回头看看例子一，<code>getName</code>函数可以访问变量<code>name</code>，但是<code>name</code>既不是<code>getName</code>函数的局部变量，也不是<code>getName</code>函数的参数，所以<code>name</code>被称为自由变量，那么函数<code>getName</code> 和 函数访问到的变量<code>name</code>就构成了一个闭包。</strong></p><p>所以在<code>《Javascript权威指南》</code>中就有讲到：<strong>从技术角度来讲，所有的Javascript函数都是闭包</strong>。</p><p>看到这，可能会有同学说怎么跟其他文章说的不一样呢！</p><p>别着急，上面👆只是理论上的闭包，其实还有一个从实践角度上的闭包，下面👇让我们看看<a href="https://www.cnblogs.com/TomXu/archive/2012/01/31/2330252.html" target="_blank" rel="noopener">汤姆大叔</a>翻译的关于闭包的文章中的定义:</p><blockquote><p>ECMAScript中，闭包指的是：<br>&nbsp;&nbsp;&nbsp;&nbsp;1、从理论角度：所有的函数。因为它们都在创建的时候将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于访问自由变量，这个时候使用了最外层的作用域。<br>&nbsp;&nbsp;&nbsp;&nbsp;2、从实践角度：以下函数才算是闭包：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数返回）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.在代码中引用了自由变量。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>让我们再来看一个简单的例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = checkscope(); <span class="comment">// foo指向函数f</span></span><br><span class="line">foo();  <span class="comment">// 调用函数f()</span></span><br></pre></td></tr></table></figure><p>首先先来简单的分析一下这段代码中执行上下文和执行上下文栈的变化情况：<br>&nbsp;&nbsp;&nbsp;&nbsp;1、进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈<br>&nbsp;&nbsp;&nbsp;&nbsp;2、全局执行上下文初始化<br>&nbsp;&nbsp;&nbsp;&nbsp;3、、执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈<br>&nbsp;&nbsp;&nbsp;&nbsp;4、checkscope 执行上下文初始化，创建变量对象、作用域链、this等<br>&nbsp;&nbsp;&nbsp;&nbsp;5、checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出6、执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈<br>&nbsp;&nbsp;&nbsp;&nbsp;7、f 执行上下文初始化，创建变量对象、作用域链、this等<br>&nbsp;&nbsp;&nbsp;&nbsp;8、f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> 深入系列 </category>
          
          <category> 深入系列 </category>
          
          <category> 闭包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 深入系列 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>498.对角线遍历 (leetcode mid)</title>
      <link href="/2019/12/26/diagonal-traverse/"/>
      <url>/2019/12/26/diagonal-traverse/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。<br>说明:给定矩阵中的元素总数不会超过 100000 。</p></blockquote><p>示例：</p><p><img src="/2019/12/26/diagonal-traverse/example.png" alt="示例"></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Javascript 解法</span></span><br><span class="line"><span class="keyword">var</span> findDiagonalOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设m为纵坐标，n为横坐标</span></span><br><span class="line">    <span class="comment">// 据题意可知，当m+n为奇数时向下遍历，m+n为偶数时向上遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历方式</span></span><br><span class="line">    <span class="comment">// 向上遍历时：m递减，n递增</span></span><br><span class="line">    <span class="comment">// 向下遍历时：m递增，n递减</span></span><br><span class="line">    <span class="comment">// 以此循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 遍历结束条件</span></span><br><span class="line"><span class="comment">     *  向上遍历：m递减到0或者n递增到最大值</span></span><br><span class="line"><span class="comment">     *  向下遍历：n递减到0或者m递增到最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化返回值</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> m = matrix.length;</span><br><span class="line">    <span class="comment">// 判断输入值长度为0直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (m === <span class="number">0</span> || (m &gt; <span class="number">0</span> &amp;&amp; matrix[<span class="number">0</span>].length === <span class="number">0</span>)) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">let</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 定义Boolean traversal值为此时的遍历方式为向上还是向下</span></span><br><span class="line">    <span class="keyword">let</span> traversal = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m + n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> pm = traversal ? m : n;</span><br><span class="line"><span class="keyword">let</span> pn = traversal ? n : m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = (i &lt; pm) ? i : pm - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = i - x;                </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; y &lt; pn) &#123;</span><br><span class="line">  res.push(traversal ? matrix[x][y] : matrix[y][x]);</span><br><span class="line">  x--;</span><br><span class="line">  y++;</span><br><span class="line">&#125;</span><br><span class="line">raversal = !traversal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this全面解析</title>
      <link href="/2019/12/23/about-this/"/>
      <url>/2019/12/23/about-this/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引子"><a href="#一、引子" class="headerlink" title="一、引子"></a>一、引子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Heternally"</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"zl"</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = obj.foo;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// "zl"</span></span><br><span class="line">foo(); <span class="comment">// "Heternally"</span></span><br></pre></td></tr></table></figure><p>可以看到上面代码中，<code>obj.foo</code>和<code>foo</code>都指向同一个函数，但是执行结果却不一样；产生这种差异的原因，就在于函数体内部使用了<code>this</code>关键字；</p><p>相信很多文章都会说，<strong><code>this</code>指向的是函数运行时所在的环境。</strong></p><p>所以上面的问题，对<code>obj.foo()</code>来说，<code>foo</code>运行在<code>obj</code>环境中，所以<code>this</code>指向<code>obj</code>；对于<code>foo()</code>来说，<code>foo</code>运行在全局环境下，所以在非严格模式下<code>this</code>指向<code>window</code>，所以导致了两者运行的结果不同；</p><p>看到这有的同学可能就有疑问了，函数的运行环境是如何判定的？为什么<code>obj.foo()</code>就是在<code>obj</code>环境，为何<code>var foo = obj.foo;</code>，<code>foo()</code>就在全局环境执行了；</p><p>接下来就跟同学们讲解一下为何<code>Javascript</code>这样处理，带你彻底理解<code>this</code>。</p><h2 id="二、为何设计this关键字"><a href="#二、为何设计this关键字" class="headerlink" title="二、为何设计this关键字"></a>二、为何设计<code>this</code>关键字</h2><p>要理解<code>this</code>的设计，我们需要先了解<code>Javascript</code>中内存的数据结构；</p><p><code>Javascript</code>内置七种数据类型，可以分为<strong>基本数据类型</strong>和<strong>对象数据类型</strong>，在这里我们主要讲解一下<strong>对象数据类型</strong>在内存中的存储方式；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Heternally'</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>Javascript</code>引擎在处理上面代码时，会在<strong>堆内存</strong>中，生成一个对象<code>{ name: &#39;Heternally&#39;}</code>，然后把这个对象在内存中的地址赋值给变量<code>obj</code>。所以在读取<code>obj.name</code>时，需要先从变量<code>obj</code>拿到地址，然后再从对应地址中拿到对象，再返回它的<code>name</code>属性。</p><p>可能看到这里会有同学要问这跟<code>this</code>有啥关系，别急，接下来重点来啦：</p><p>对象的属性可能是一个函数，当引擎遇到对象属性是函数的情况，会将函数单独保存在<strong>堆</strong>中，然后再将函数的地址赋值给对象属性；而<code>Javascript</code>是允许在函数体内引用当前环境的其他变量，那么问题来了，函数可以在不同的运行环境执行，所以我们就需要一种机制，能够在函数内获得当前运行环境，由此诞生了<code>this</code>，<strong>它的设计目的就是指向函数运行时所在的环境。</strong></p><p>理解了<code>this</code>的设计，剩下的难点就是如何正确的判定它所指向的环境。</p><h2 id="三、如何正确判定this指向"><a href="#三、如何正确判定this指向" class="headerlink" title="三、如何正确判定this指向"></a>三、如何正确判定<code>this</code>指向</h2><p>总结了<code>this</code>的绑定规则总共是有下面5种：</p><ul><li>1、默认绑定（严格/非严格模式）</li><li>2、隐式绑定</li><li>3、显式绑定</li><li>4、new绑定</li><li>5、ES6箭头函数绑定</li></ul><h3 id="1、默认绑定"><a href="#1、默认绑定" class="headerlink" title="1、默认绑定"></a>1、默认绑定</h3><h4 id="1-1-严格模式"><a href="#1-1-严格模式" class="headerlink" title="1.1 严格模式"></a>1.1 严格模式</h4><p>在严格模式下，不能将全局对象<code>window</code>作为默认绑定，此时<code>this</code>会绑定到<code>undefined</code>，但是在严格模式下调用函数则不会影响默认绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Heternally"</span>;</span><br><span class="line">  foo(); </span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property 'name' of undefined at foo</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Heternally'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="meta">  "use strict"</span></span><br><span class="line">  foo();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure><h4 id="1-2-非严格模式"><a href="#1-2-非严格模式" class="headerlink" title="1.2 非严格模式"></a>1.2 非严格模式</h4><p>在非严格模式下，此时<code>this</code>就指向<strong>全局对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Heternally'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure><h3 id="2、隐式绑定"><a href="#2、隐式绑定" class="headerlink" title="2、隐式绑定"></a>2、隐式绑定</h3><p>当函数作为对象的属性存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Heternally'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zl'</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// zl</span></span><br></pre></td></tr></table></figure><p>注意上面代码中函数执行方式是通过<strong>对象属性</strong>执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Heternally'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zl'</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = obj.foo; </span><br><span class="line"></span><br><span class="line">foo1(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">obj.foo(); <span class="comment">// zl</span></span><br></pre></td></tr></table></figure><p>由上面代码可以发现，通过赋值操作后执行函数，会应用默认绑定，此时在非严格模式下<code>this</code>会指向全局对象。</p><p>同样的，函数传参也是一种隐式赋值，此时在回调函数中会丢失<code>this</code>绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zl'</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Heternally'</span>;</span><br><span class="line"></span><br><span class="line">Foo(obj.foo); <span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure><h3 id="3、显式绑定"><a href="#3、显式绑定" class="headerlink" title="3、显式绑定"></a>3、显式绑定</h3><p><strong>通过 <code>call</code> <code>apply</code> <code>bind</code>绑定</strong></p><p>相信同学们都知道这三个方法的作用，这边就主要拿<code>call</code>来举例；</p><blockquote><p>一句话介绍<code>call</code>：使用一个指定的<code>this</code>和若干个指定的参数调用某个函数或方法。</p></blockquote><p>在讲解<code>call</code>显示绑定之前，我们先想一下<code>call</code>做了哪些事儿。</p><ul><li>将函数设为对象的属性</li><li>指定函数的this，并进行传参</li><li>执行&amp;删除函数</li><li>判定如果没有指定要绑定的this，非严格模式下默认指向全局对象</li></ul><p>可以看到值调用<code>call</code>方法后，会将<code>this</code>绑定到指定对象，所以称为<strong>显示绑定</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Heternally'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'Heternally1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'zl'</span>;</span><br><span class="line"></span><br><span class="line">foo.call(obj); <span class="comment">// Heternally  调用call方法后强行将foo函数的this指向来obj对象上</span></span><br><span class="line"></span><br><span class="line">foo.call(obj).call(obj1); <span class="comment">// Heternally  多次调用call方法，以第一次为准</span></span><br><span class="line"></span><br><span class="line">foo.call(obj1).call(obj); <span class="comment">// Heternally1</span></span><br><span class="line"></span><br><span class="line">foo.call();<span class="comment">// zl 没有传入指定对象，所以this默认指向全局对象</span></span><br></pre></td></tr></table></figure><blockquote><p>如果call、apple、bind的绑定对象是null或者undefined，那么实际上在调用时这些值都会被忽略，所以使用的是默认绑定规则</p></blockquote><h3 id="4、通过new绑定"><a href="#4、通过new绑定" class="headerlink" title="4、通过new绑定"></a>4、通过new绑定</h3><p>我们先看看构造函数在使用<code>new</code>后，执行了什么操作：</p><ul><li>它创建（构造）了一个全新的对象</li><li>它会被执行[[Prototype]]（也就是<strong>proto</strong>）链接</li><li>它使this指向新创建的对象</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用</li></ul><p>所以在使用<code>new</code>调用构造函数后，会构造一个新对象并将函数调用中的<code>this</code>绑定到新对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'zl'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  name: <span class="string">'object'</span>,</span><br><span class="line">  foo1: <span class="keyword">new</span> foo(<span class="string">'Heternally'</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.foo1.name); <span class="comment">// Heternally</span></span><br></pre></td></tr></table></figure><p>构造函数是存在返回值的，可以将函数的返回值分成三种情况：</p><ul><li>返回一个对象</li><li>没有返回值，即默认返回<code>undefined</code></li><li>返回基本数据类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、返回一个对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">"Heternally"</span>,<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、没有返回值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">"Heternally"</span>,<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、返回基本数据类型</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">"Heternally"</span>,<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>所以使用<code>new</code>绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么<code>this</code>会绑定到返回的对象上。</p><h3 id="5、ES6箭头函数绑定"><a href="#5、ES6箭头函数绑定" class="headerlink" title="5、ES6箭头函数绑定"></a>5、ES6箭头函数绑定</h3><p>ES6新增了一种函数类型：箭头函数，箭头函数调用时无法使用上面四种规则了，它和普通函数最不同的一点就是对于箭头函数的<code>this</code>指向，是根据它外层（函数/全局）作用域来决定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Heternally'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'text'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'zl'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo1 = foo();</span><br><span class="line">foo1(); <span class="comment">// zl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo2 = foo.call(obj);</span><br><span class="line">foo2(); <span class="comment">// Heternally</span></span><br><span class="line"></span><br><span class="line">foo2.call(obj1); <span class="comment">// Heternally 可以看到，箭头函数的`this`绑定后无法被修改</span></span><br></pre></td></tr></table></figure><h3 id="6、规则优先级"><a href="#6、规则优先级" class="headerlink" title="6、规则优先级"></a>6、规则优先级</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="keyword">new</span>绑定</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">this</span>绑定新的对象上</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、显示绑定</span><br><span class="line"><span class="keyword">var</span> obj = foo.call(bar);</span><br><span class="line"><span class="keyword">this</span>绑定到指定对象上，若指定对象为<span class="literal">null</span>/<span class="literal">undefined</span>或着没传，则使用默认绑定规则</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、隐式绑定</span><br><span class="line"><span class="keyword">var</span> obj = bar.foo();</span><br><span class="line"><span class="keyword">this</span>绑定到调用方法的对象上</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、默认绑定</span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">this</span>在严格模式下绑定到<span class="literal">undefined</span></span><br><span class="line">在非严格模式下绑定到全局对象</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
          <category> 深入系列 </category>
          
          <category> 深入系列 </category>
          
          <category> this </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 深入系列 </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/19/hello-world/"/>
      <url>/2019/12/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
