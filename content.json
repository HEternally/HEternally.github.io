{"meta":{"title":"Heternally","subtitle":"","description":"Heternally博客，前端博客，前端技术博客，算法学习，LeetCode题解","author":"Heternally","url":"https://heternally.github.io","root":"/"},"pages":[{"title":"分类页","date":"2019-12-20T10:08:55.000Z","updated":"2019-12-20T10:29:15.298Z","comments":true,"path":"categories/index.html","permalink":"https://heternally.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-12-20T09:22:40.312Z","updated":"2019-12-20T09:22:40.312Z","comments":true,"path":"about/index.html","permalink":"https://heternally.github.io/about/index.html","excerpt":"","text":""},{"title":"标签页","date":"2019-12-20T10:08:55.000Z","updated":"2019-12-20T10:29:18.906Z","comments":true,"path":"tags/index.html","permalink":"https://heternally.github.io/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2019-12-26T08:48:38.904Z","updated":"2019-12-19T16:00:00.000Z","comments":true,"path":"friends/index.html","permalink":"https://heternally.github.io/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： Heternally头像： http://marketing.zone1.meitudata.com/08b808c8fd933b59b75894ba6ce25748-3483.jpeg网站： https://heternally.github.io/标签： 前端 分组和标签不合适的话可以留言或者发邮件私聊我进行更改。头像尺寸是64px，3倍精细度就足够了，也就是192px，如果文件体积太大可以压缩一下。"}],"posts":[{"title":"算法学习之递归、迭代、分治法","slug":"recursive-iteration-divide","date":"2020-01-04T16:10:04.000Z","updated":"2020-01-04T16:35:09.172Z","comments":true,"path":"2020/01/05/recursive-iteration-divide/","link":"","permalink":"https://heternally.github.io/2020/01/05/recursive-iteration-divide/","excerpt":"","text":"递归、迭代和分治法一、递归算法 通过不断调用自身，但是相对的每次调用自己时候，所解决的问题规模较小，比较符合分治的思想。 1、使用递归要注意的有两点: 递归就是在过程或函数里面调用自身;在使用递归时,必须有一个明确的递归结束条件,称为递归出口. 2、递归分为两个阶段: 递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;回归:当获得最简单的情况后,逐步返回,依次得到复杂的解.利用递归可以解决很多问题:如背包问题,汉诺塔问题,…等. 3、优缺点 优点：结构清晰，可读性强，且容易用数学归纳法证明算法的正确性。缺点：(1) 递归算法需要调用递归栈存放函数的变量、计算结果等直至return后才会释放该栈，所以消耗内存空间； (2) 可能存在重复计算相同的子问题。 二、分治法 将一个规模为n的问题分解为k个规模较小的子问题，这些子问题相互独立且与原问题相同，然后递归地解这些子问题，最后将各个子问题的解合并得到原问题的解。 应用：二分搜索、大整数乘法。 三、迭代 从小规模的问题，逐步累积出较大问题的解，最终获得所需要解决问题的解","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/categories/Javascript/"},{"name":"算法学习","slug":"算法学习","permalink":"https://heternally.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/tags/Javascript/"},{"name":"算法学习","slug":"算法学习","permalink":"https://heternally.github.io/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}]},{"title":"21.合并两个有序列表 (leetcode easy)","slug":"merge-two-sorted-lists","date":"2020-01-02T02:36:40.000Z","updated":"2020-01-02T02:57:09.408Z","comments":true,"path":"2020/01/02/merge-two-sorted-lists/","link":"","permalink":"https://heternally.github.io/2020/01/02/merge-two-sorted-lists/","excerpt":"","text":"题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 思路一：递归本题递归三要素：1、终止条件：两条链表分别名为l1和l2，当l1或l2为空时结束2、返回值：每一层调用都返回排序好的链表头3、递归内容：如果l1的val值更小，则将l1.next与排序好的链表头相接，l2同理 时间复杂度：O(m+n)，m为l1的长度，n为l2的长度空间复杂度：O(m+n)，递归结束后，l1和l2的每个元素都已经遍历过了 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(l1, l2) &#123; if(l1 === null)&#123; return l2; &#125; if(l2 === null)&#123; return l1; &#125; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125;else&#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125;; 思路二：迭代设定哨兵节点“prehead“，这可以在最后让我们比较容易的返回合并后的链表，然后我们只需要维护一个prev指针，需要做的是调整它的next指针。然后，我们重复以下过程，直到l1或者l2指向了null：如果l1当前位置的值小于等于l2，我们就把l1的值接在prev节点的后面同时将l1指针往后移一位，否则操作l2。不管我们将哪一个元素接在后面，都将prev向后移一个元素 在循环终止的时候，l1和l2至多有一个非空的。由于输入的两个链表都是有序的，所以不管哪个链表非空，它包含的所有元素都比前面已经合并链表中的元素大，所有我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(l1, l2) &#123; let prehead = new ListNode(-1); let prev = prehead; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; prev.next = l1 == null ? l2 : l1; return prehead.next;&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/categories/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/categories/Leetcode/"},{"name":"linkedList","slug":"Leetcode/linkedList","permalink":"https://heternally.github.io/categories/Leetcode/linkedList/"},{"name":"腾讯","slug":"Leetcode/腾讯","permalink":"https://heternally.github.io/categories/Leetcode/%E8%85%BE%E8%AE%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/tags/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/tags/Leetcode/"},{"name":"linkedList","slug":"linkedList","permalink":"https://heternally.github.io/tags/linkedList/"},{"name":"腾讯","slug":"腾讯","permalink":"https://heternally.github.io/tags/%E8%85%BE%E8%AE%AF/"}]},{"title":"2.两数相加 (leetcode mid)","slug":"add-two-numbers","date":"2019-12-31T08:11:16.000Z","updated":"2020-01-02T02:39:15.231Z","comments":true,"path":"2019/12/31/add-two-numbers/","link":"","permalink":"https://heternally.github.io/2019/12/31/add-two-numbers/","excerpt":"","text":"题目 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 思路1、标签：链表2、将两个链表按长的进行遍历，如果遇到短链表不够长度则在前面补0，比如987 + 23 = 987 + 023 = 10103、每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值4、如果两个链表都遍历完后，进位值仍为1，则在新链表最前方添加节点1 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; let p1 = l1; let p2 = l2; let carry = 0; const dummy = new ListNode(); let pointer = dummy; while (p1 || p2) &#123; const num1 = p1 ? p1.val : 0; const num2 = p2 ? p2.val : 0; const sum = num1 + num2 + carry; carry = parseInt(sum / 10); pointer.next = new ListNode(sum % 10); if (p1) p1 = p1.next if (p2) p2 = p2.next pointer = pointer.next &#125; if(carry == 1) &#123; pointer.next = new ListNode(1); &#125; return dummy.next&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/categories/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/categories/Leetcode/"},{"name":"linkedList","slug":"Leetcode/linkedList","permalink":"https://heternally.github.io/categories/Leetcode/linkedList/"},{"name":"Leetcode,腾讯","slug":"Leetcode-腾讯","permalink":"https://heternally.github.io/categories/Leetcode-%E8%85%BE%E8%AE%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/tags/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/tags/Leetcode/"},{"name":"linkedList","slug":"linkedList","permalink":"https://heternally.github.io/tags/linkedList/"},{"name":"腾讯","slug":"腾讯","permalink":"https://heternally.github.io/tags/%E8%85%BE%E8%AE%AF/"}]},{"title":"74.搜索二维矩阵 (leetcode mid)","slug":"search-a-2d-matrix","date":"2019-12-30T06:08:07.000Z","updated":"2019-12-30T06:37:45.409Z","comments":true,"path":"2019/12/30/search-a-2d-matrix/","link":"","permalink":"https://heternally.github.io/2019/12/30/search-a-2d-matrix/","excerpt":"","text":"题目编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：&nbsp;&nbsp;&nbsp;&nbsp;1、每行中的整数从左到右按升序排列。&nbsp;&nbsp;&nbsp;&nbsp;2、每行的第一个整数大于前一行的最后一个整数。 思路一：骚操作 可以看到本题目的是操作数组中是否有目标值，那么我们可以使用数组方法includes(),但是这里是二维数组，那么我们可以用数组的flat()方法来将二维数组转为一维数组。 123var searchMatrix = function (matrix, target) &#123; return matrix.flat().includes(target);&#125; 1234// 兼容代码var searchMatrix = function (matrix, target) &#123; return [].concat(...matrix).includes(target);&#125; 思路二：递归 我们可以采用递进式的方法，从二维数组的右上角开始比对 1234567891011121314151617var searchMatrix = function(matrix, target) &#123; if (matrix.length === 0 || (matrix.length &gt; 0 &amp;&amp; matrix[0].length === 0)) return false; let m = matrix.length, n = matrix[0].length, i = 0, j = n - 1; while(i&lt;m &amp;&amp; j&gt;= 0)&#123; if (matrix[i][j] &gt; target)&#123; j--; &#125;else if (matrix[i][j] &lt; target)&#123; i++; &#125;else &#123; return true; &#125; &#125; return false;&#125; 思路三：二分法 此题的二维数组可以被看作是一个升序的一维数组，那么我们就可以直接使用二分法 123456789101112131415161718var searchMatrix = function(matrix, target) &#123; if (matrix.length === 0 || (matrix.length &gt; 0 &amp;&amp; matrix[0].length === 0)) return false; let start,mid,num; let m = matrix.length, n = matrix[0].length, end = m * n - 1; start = mid = 0; while (start &lt;= end) &#123; mid = parseInt((start + end) / 2); num = matrix[parseInt(mid / n)][mid % n]; if (target == num) return true; else &#123; if (target &lt; num) end = mid - 1; else start = mid + 1; &#125; &#125; return false;&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/categories/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/categories/Leetcode/"},{"name":"Array","slug":"Leetcode/Array","permalink":"https://heternally.github.io/categories/Leetcode/Array/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/tags/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://heternally.github.io/tags/Array/"}]},{"title":"162.寻找峰值 (leetcode mid)","slug":"find-peak-element","date":"2019-12-29T14:09:27.000Z","updated":"2019-12-29T14:31:25.371Z","comments":true,"path":"2019/12/29/find-peak-element/","link":"","permalink":"https://heternally.github.io/2019/12/29/find-peak-element/","excerpt":"","text":"题目 峰值元素是指其值大于左右相邻值的元素。给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。你可以假设 nums[-1] = nums[n] = -∞。 说明：你的解法应该是 O(logN) 时间复杂度的。 思路一：1、标签：暴力法2、过程：题目给出了muns[-1] = nums[n] = -∞，所以nums[0] &gt; nums[-1]必定成立，那么我们只需要遍历数组，找到第一个i使得nums[i] &gt; nums[i+1]；例如：nums[0] &gt; nums[1],且此时nums[0] &gt; nums[-1]，则得出峰值元素下标为0。3、时间复杂度：最差的情况下为O(n)，最好的情况下为O(1) 12345678910var findPeakElement = function(nums) &#123; if (nums.length === 1) return 0; let i = 0; for(; i &lt; nums.length - 1; i++)&#123; if(nums[i] &gt; nums[i+1])&#123; break &#125; &#125; return i&#125;; 思路二：1、标签：二分查找2、过程： i.首先要注意题目条件，在题目描述中出现了 nums[-1] = nums[n] = -∞，这就代表着 只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值 ii.根据上述结论，我们就可以使用二分查找找到峰值 iii.查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件 Vi.根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r = m，如果 m + 1 较大，则右侧存在峰值，l = m + 13、时间复杂度：O(logN) 12345678910111213141516var findPeakElement = function(nums) &#123; // 题目要求时间复杂度为O(logn)，那么我们就想到可以使用二分法解决； if (nums.length === 1) return 0; let star = 0; let end = nums.length - 1; let mid; while( star &lt; end ) &#123; mid = parseInt((star + end) / 2); if (nums[mid] &lt; nums[mid + 1]) &#123; star = mid + 1; &#125; else &#123; end = mid; &#125; &#125; return star;&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/categories/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/categories/Leetcode/"},{"name":"Array","slug":"Leetcode/Array","permalink":"https://heternally.github.io/categories/Leetcode/Array/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/tags/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://heternally.github.io/tags/Array/"}]},{"title":"41.缺失的第一个正数 (leetcode hard)","slug":"first-missing-positive","date":"2019-12-27T07:06:54.000Z","updated":"2019-12-27T07:29:16.548Z","comments":true,"path":"2019/12/27/first-missing-positive/","link":"","permalink":"https://heternally.github.io/2019/12/27/first-missing-positive/","excerpt":"","text":"题目 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 解法思路思路一遍历一次数组把大于等于1的和小于数组大小的值放到原数组对应位置，然后再遍历一次数组查当前下标是否和值对应，如果不对应那这个下标就是答案，否则遍历完都没出现那么答案就是数组长度加1。 1234567891011121314151617181920if (nums.length === 0 || (nums.length === 1 &amp;&amp; nums[0] != 1) ) return 1;function swap(i,j)&#123; nums[i] = nums[i] ^ nums[j]; nums[j] = nums[i] ^ nums[j]; nums[i] = nums[i] ^ nums[j];&#125;// 桶排序let len = nums.length;for(let i=0;i&lt;len;i++)&#123; // 新索引 nums[i] 处于 [1,length] 且不等于自身（如第三项不能为3：nums[2]!==3） 且 nums[新索引] 未排好 while(nums[i]&gt;=1&amp;&amp;nums[i]&lt;=len&amp;&amp;nums[i]!==i+1&amp;&amp;nums[nums[i]-1]!==nums[i])&#123; swap(i,nums[i]-1) &#125;&#125;for(let j=0;j&lt;len;j++)&#123; if(nums[j]!==j+1)&#123; return j+1 &#125;&#125;return len + 1 思路二定义空数组，循环目标数组，将空数组中对应目标数组值的下标设为true；最后遍历定义的数组，返回第一个值不为true的下标 12345678910111213let arr=[],len=nums.length;if(len===0||len===1&amp;&amp;nums[0]!==1)return 1for(let i=0;i&lt;len;i++)&#123; if(nums[i]&gt;=0)arr[nums[i]]=true&#125;if(!arr.length)return 1let len1=arr.length;for(let i=1;i&lt;len1;i++)&#123; if(!arr[i])&#123; return i &#125; if(i===len1-1)return len1;&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/categories/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/categories/Leetcode/"},{"name":"Array","slug":"Leetcode/Array","permalink":"https://heternally.github.io/categories/Leetcode/Array/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/tags/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://heternally.github.io/tags/Array/"}]},{"title":"Javascript深入之闭包","slug":"closure","date":"2019-12-26T09:20:20.000Z","updated":"2019-12-29T15:27:43.162Z","comments":true,"path":"2019/12/26/closure/","link":"","permalink":"https://heternally.github.io/2019/12/26/closure/","excerpt":"","text":"引子闭包（closure）属于Javascript的一个难点，很多高级应用都需要依赖闭包实现； 首先先来个例子： 例子一： 12345let name = 'Heternally';function getName() &#123; console.log(name);&#125;getName(); // Heternally 可以看到，函数getName内可以读取全局变量；但是，在函数外就无法读取函数内部声明的变量。 例子二： 1234function getName() &#123; var name = 'Heternally';&#125;console.log(name); // name is not defined 有同学看到这可能会说，这不是作用域链的问题嘛，但是咱在这里是为了引出闭包； 定义MDN给到闭包的定义是： 闭包是指那些能够访问自由变量的函数 什么是自由变量呢？ 自由变量是指在函数中使用，但既不是函数的参数也不是函数局部变量的变量，其实就是另一个函数作用域中的变量 关于这个也可以从红宝书上对于闭包的定义中看出：闭包是指有权访问另外一个函数作用域的变量的函数 因此，可以得出闭包由两部分组成： 闭包 = 函数 + 函数可访问的自由变量 现在我们再来回头看看例子一，getName函数可以访问变量name，但是name既不是getName函数的局部变量，也不是getName函数的参数，所以name被称为自由变量，那么函数getName 和 函数访问到的变量name就构成了一个闭包。 所以在《Javascript权威指南》中就有讲到：从技术角度来讲，所有的Javascript函数都是闭包。 看到这，可能会有同学说怎么跟其他文章说的不一样呢！ 别着急，上面👆只是理论上的闭包，其实还有一个从实践角度上的闭包，下面👇让我们看看汤姆大叔翻译的关于闭包的文章中的定义: ECMAScript中，闭包指的是：&nbsp;&nbsp;&nbsp;&nbsp;1、从理论角度：所有的函数。因为它们都在创建的时候将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于访问自由变量，这个时候使用了最外层的作用域。&nbsp;&nbsp;&nbsp;&nbsp;2、从实践角度：以下函数才算是闭包：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数返回）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii.在代码中引用了自由变量。 分析让我们再来看一个简单的例子: 1234567891011var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope(); // foo指向函数ffoo(); // 调用函数f() 首先先来简单的分析一下这段代码中执行上下文和执行上下文栈的变化情况：&nbsp;&nbsp;&nbsp;&nbsp;1、进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈&nbsp;&nbsp;&nbsp;&nbsp;2、全局执行上下文初始化&nbsp;&nbsp;&nbsp;&nbsp;3、、执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈&nbsp;&nbsp;&nbsp;&nbsp;4、checkscope 执行上下文初始化，创建变量对象、作用域链、this等&nbsp;&nbsp;&nbsp;&nbsp;5、checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出6、执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈&nbsp;&nbsp;&nbsp;&nbsp;7、f 执行上下文初始化，创建变量对象、作用域链、this等&nbsp;&nbsp;&nbsp;&nbsp;8、f 函数执行完毕，f 函数上下文从执行上下文栈中弹出","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/categories/Javascript/"},{"name":"深入系列","slug":"Javascript/深入系列","permalink":"https://heternally.github.io/categories/Javascript/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"},{"name":"深入系列","slug":"深入系列","permalink":"https://heternally.github.io/categories/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"},{"name":"闭包","slug":"深入系列/闭包","permalink":"https://heternally.github.io/categories/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/%E9%97%AD%E5%8C%85/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/tags/Javascript/"},{"name":"深入系列","slug":"深入系列","permalink":"https://heternally.github.io/tags/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"},{"name":"闭包","slug":"闭包","permalink":"https://heternally.github.io/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"498.对角线遍历 (leetcode mid)","slug":"diagonal-traverse","date":"2019-12-26T07:43:12.000Z","updated":"2019-12-27T07:09:02.192Z","comments":true,"path":"2019/12/26/diagonal-traverse/","link":"","permalink":"https://heternally.github.io/2019/12/26/diagonal-traverse/","excerpt":"","text":"题目 给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。说明:给定矩阵中的元素总数不会超过 100000 。 示例： 解法12345678910111213141516171819202122232425262728293031323334353637383940// Javascript 解法var findDiagonalOrder = function(matrix) &#123; // 设m为纵坐标，n为横坐标 // 据题意可知，当m+n为奇数时向下遍历，m+n为偶数时向上遍历 // 遍历方式 // 向上遍历时：m递减，n递增 // 向下遍历时：m递增，n递减 // 以此循环 /** 遍历结束条件 * 向上遍历：m递减到0或者n递增到最大值 * 向下遍历：n递减到0或者m递增到最大值 */ // 初始化返回值 let res = []; let m = matrix.length; // 判断输入值长度为0直接返回 if (m === 0 || (m &gt; 0 &amp;&amp; matrix[0].length === 0)) return res; let n = matrix[0].length; // 定义Boolean traversal值为此时的遍历方式为向上还是向下 let traversal = true; for (let i = 0; i &lt; m + n - 1; i++) &#123; let pm = traversal ? m : n; let pn = traversal ? n : m; let x = (i &lt; pm) ? i : pm - 1; let y = i - x; while (x &gt;= 0 &amp;&amp; y &lt; pn) &#123; res.push(traversal ? matrix[x][y] : matrix[y][x]); x--; y++; &#125; raversal = !traversal; &#125; return res;&#125;;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/categories/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/categories/Leetcode/"},{"name":"Array","slug":"Leetcode/Array","permalink":"https://heternally.github.io/categories/Leetcode/Array/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/tags/Javascript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://heternally.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"https://heternally.github.io/tags/Array/"}]},{"title":"this全面解析","slug":"about-this","date":"2019-12-23T04:04:25.000Z","updated":"2019-12-26T09:31:33.828Z","comments":true,"path":"2019/12/23/about-this/","link":"","permalink":"https://heternally.github.io/2019/12/23/about-this/","excerpt":"","text":"一、引子123456789101112var name = \"Heternally\";var obj = &#123; name: \"zl\", foo: function() &#123; console.log(this.name); &#125;&#125;;var foo = obj.foo;obj.foo(); // \"zl\"foo(); // \"Heternally\" 可以看到上面代码中，obj.foo和foo都指向同一个函数，但是执行结果却不一样；产生这种差异的原因，就在于函数体内部使用了this关键字； 相信很多文章都会说，this指向的是函数运行时所在的环境。 所以上面的问题，对obj.foo()来说，foo运行在obj环境中，所以this指向obj；对于foo()来说，foo运行在全局环境下，所以在非严格模式下this指向window，所以导致了两者运行的结果不同； 看到这有的同学可能就有疑问了，函数的运行环境是如何判定的？为什么obj.foo()就是在obj环境，为何var foo = obj.foo;，foo()就在全局环境执行了； 接下来就跟同学们讲解一下为何Javascript这样处理，带你彻底理解this。 二、为何设计this关键字要理解this的设计，我们需要先了解Javascript中内存的数据结构； Javascript内置七种数据类型，可以分为基本数据类型和对象数据类型，在这里我们主要讲解一下对象数据类型在内存中的存储方式； 1var obj = &#123; name: 'Heternally'&#125;; Javascript引擎在处理上面代码时，会在堆内存中，生成一个对象{ name: &#39;Heternally&#39;}，然后把这个对象在内存中的地址赋值给变量obj。所以在读取obj.name时，需要先从变量obj拿到地址，然后再从对应地址中拿到对象，再返回它的name属性。 可能看到这里会有同学要问这跟this有啥关系，别急，接下来重点来啦： 对象的属性可能是一个函数，当引擎遇到对象属性是函数的情况，会将函数单独保存在堆中，然后再将函数的地址赋值给对象属性；而Javascript是允许在函数体内引用当前环境的其他变量，那么问题来了，函数可以在不同的运行环境执行，所以我们就需要一种机制，能够在函数内获得当前运行环境，由此诞生了this，它的设计目的就是指向函数运行时所在的环境。 理解了this的设计，剩下的难点就是如何正确的判定它所指向的环境。 三、如何正确判定this指向总结了this的绑定规则总共是有下面5种： 1、默认绑定（严格/非严格模式） 2、隐式绑定 3、显式绑定 4、new绑定 5、ES6箭头函数绑定 1、默认绑定1.1 严格模式在严格模式下，不能将全局对象window作为默认绑定，此时this会绑定到undefined，但是在严格模式下调用函数则不会影响默认绑定。 12345678910(() =&gt; &#123; \"use strict\" function foo() &#123; console.log(this.name); &#125;; var name = \"Heternally\"; foo(); &#125;)();// Uncaught TypeError: Cannot read property 'name' of undefined at foo 1234567891011var name = 'Heternally';function foo() &#123; console.log(this.name);&#125;;(() =&gt; &#123; \"use strict\" foo();&#125;)();// Heternally 1.2 非严格模式在非严格模式下，此时this就指向全局对象 123456var name = 'Heternally';function foo() &#123; console.log(this.name);&#125;foo(); // Heternally 2、隐式绑定当函数作为对象的属性存在，通过对象属性执行函数时，此时隐式绑定规则会将this绑定到对象上； 1234567891011var name = 'Heternally';function foo() &#123; console.log(this.name);&#125;var obj = &#123; name: 'zl', foo,&#125;obj.foo(); // zl 注意上面代码中函数执行方式是通过对象属性执行 1234567891011121314151617var name = 'Heternally';function foo() &#123; console.log(this.name);&#125;var obj = &#123; name: 'zl', foo,&#125;foo(); // Heternallyvar foo1 = obj.foo; foo1(); // Heternallyobj.foo(); // zl 由上面代码可以发现，通过赋值操作后执行函数，会应用默认绑定，此时在非严格模式下this会指向全局对象。 同样的，函数传参也是一种隐式赋值，此时在回调函数中会丢失this绑定。 12345678910111213141516function foo() &#123; console.log(this.name);&#125;function Foo(fn) &#123; fn();&#125;var obj = &#123; name: 'zl', foo,&#125;var name = 'Heternally';Foo(obj.foo); // Heternally 3、显式绑定通过 call apply bind绑定 相信同学们都知道这三个方法的作用，这边就主要拿call来举例； 一句话介绍call：使用一个指定的this和若干个指定的参数调用某个函数或方法。 在讲解call显示绑定之前，我们先想一下call做了哪些事儿。 将函数设为对象的属性 指定函数的this，并进行传参 执行&amp;删除函数 判定如果没有指定要绑定的this，非严格模式下默认指向全局对象 可以看到值调用call方法后，会将this绑定到指定对象，所以称为显示绑定 123456789101112131415161718192021function foo() &#123; console.log(this.name);&#125;var obj = &#123; name: 'Heternally',&#125;var obj1 = &#123; name: 'Heternally1'&#125;var name = 'zl';foo.call(obj); // Heternally 调用call方法后强行将foo函数的this指向来obj对象上foo.call(obj).call(obj1); // Heternally 多次调用call方法，以第一次为准foo.call(obj1).call(obj); // Heternally1foo.call();// zl 没有传入指定对象，所以this默认指向全局对象 如果call、apple、bind的绑定对象是null或者undefined，那么实际上在调用时这些值都会被忽略，所以使用的是默认绑定规则 4、通过new绑定我们先看看构造函数在使用new后，执行了什么操作： 它创建（构造）了一个全新的对象 它会被执行[[Prototype]]（也就是proto）链接 它使this指向新创建的对象 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用 所以在使用new调用构造函数后，会构造一个新对象并将函数调用中的this绑定到新对象上。 123456789101112var name = 'zl';function foo(name) &#123; this.name = name;&#125;var bar = &#123; name: 'object', foo1: new foo('Heternally'),&#125;console.log(bar.foo1.name); // Heternally 构造函数是存在返回值的，可以将函数的返回值分成三种情况： 返回一个对象 没有返回值，即默认返回undefined 返回基本数据类型 12345678910111213141516171819202122232425262728293031323334353637381、返回一个对象function Foo(name,age) &#123; this.name = name; return &#123; age &#125;&#125;var bar = new Foo(\"Heternally\",\"18\");bar.name; // undefinedbar.age; // 182、没有返回值function Foo(name,age) &#123; this.name = name;&#125;var bar = new Foo(\"Heternally\",\"18\");bar.name; // Heternallybar.age; // undefined3、返回基本数据类型function Foo(name,age) &#123; this.name = name; return 123&#125;var bar = new Foo(\"Heternally\",\"18\");bar.name; // Heternallybar.age; // undefined 所以使用new绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么this会绑定到返回的对象上。 5、ES6箭头函数绑定ES6新增了一种函数类型：箭头函数，箭头函数调用时无法使用上面四种规则了，它和普通函数最不同的一点就是对于箭头函数的this指向，是根据它外层（函数/全局）作用域来决定。 1234567891011121314151617181920212223function foo() &#123; return (name) =&gt; &#123; console.log(this.name); &#125;&#125;var obj = &#123; name: 'Heternally'&#125;var obj1 = &#123; name: 'text'&#125;var name = 'zl';var foo1 = foo();foo1(); // zlvar foo2 = foo.call(obj);foo2(); // Heternallyfoo2.call(obj1); // Heternally 可以看到，箭头函数的`this`绑定后无法被修改 6、规则优先级123456789101112131415161、new绑定var obj = new Foo();this绑定新的对象上2、显示绑定var obj = foo.call(bar);this绑定到指定对象上，若指定对象为null/undefined或着没传，则使用默认绑定规则3、隐式绑定var obj = bar.foo();this绑定到调用方法的对象上4、默认绑定foo();this在严格模式下绑定到undefined在非严格模式下绑定到全局对象","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/categories/Javascript/"},{"name":"深入系列","slug":"Javascript/深入系列","permalink":"https://heternally.github.io/categories/Javascript/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"},{"name":"深入系列","slug":"深入系列","permalink":"https://heternally.github.io/categories/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"},{"name":"this","slug":"深入系列/this","permalink":"https://heternally.github.io/categories/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/this/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://heternally.github.io/tags/Javascript/"},{"name":"深入系列","slug":"深入系列","permalink":"https://heternally.github.io/tags/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97/"},{"name":"this","slug":"this","permalink":"https://heternally.github.io/tags/this/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-12-19T08:46:41.596Z","updated":"2019-12-23T02:49:50.081Z","comments":true,"path":"2019/12/19/hello-world/","link":"","permalink":"https://heternally.github.io/2019/12/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://heternally.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://heternally.github.io/tags/hexo/"}]}]}